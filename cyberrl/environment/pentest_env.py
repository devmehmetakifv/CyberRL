"""
Penetration Testing Environment for Reinforcement Learning
"""

import gymnasium as gym
import numpy as np
from gymnasium import spaces
import nmap
import json
import logging
from typing import Dict, List, Tuple, Optional, Any, Union
import os
import time
import subprocess
from enum import Enum

class ActionType(Enum):
    """Action types available to the agent"""
    SCAN_NETWORK = 0
    SCAN_PORT = 1
    SERVICE_DETECTION = 2
    OS_DETECTION = 3
    VULN_SCAN = 4
    EXPLOIT_ATTEMPT = 5
    PRIVILEGE_ESCALATION = 6
    LATERAL_MOVEMENT = 7

class PentestEnv(gym.Env):
    """
    Penetration Testing Environment
    
    The environment simulates a network with potential vulnerabilities
    where the agent needs to perform penetration testing operations.
    """
    metadata = {'render_modes': ['human', 'ansi']}
    
    def __init__(self, 
                 target_network: str = "192.168.1.0/24",
                 max_steps: int = 100,
                 real_execution: bool = False,
                 render_mode: Optional[str] = None,
                 log_level: str = "INFO",
                 reward_config: Optional[Dict] = None):
        """
        Initialize the penetration testing environment
        
        Args:
            target_network: The target network range in CIDR notation
            max_steps: Maximum number of steps before termination
            real_execution: Whether to execute commands on the real network or simulate
            render_mode: The render mode ('human' or 'ansi')
            log_level: Logging level
            reward_config: Custom reward configuration
        """
        super(PentestEnv, self).__init__()
        
        # Setup logging
        self.logger = logging.getLogger("PentestEnv")
        log_level_dict = {"DEBUG": logging.DEBUG, "INFO": logging.INFO, 
                         "WARNING": logging.WARNING, "ERROR": logging.ERROR}
        self.logger.setLevel(log_level_dict.get(log_level, logging.INFO))
        
        # Environment configuration
        self.target_network = target_network
        self.max_steps = max_steps
        self.real_execution = real_execution
        self.render_mode = render_mode
        
        # Default reward configuration
        self.reward_config = {
            'discover_host': 5.0,
            'open_port': 1.0,
            'service_identified': 2.0,
            'os_identified': 3.0,
            'vulnerability_found': 10.0,
            'successful_exploit': 50.0,
            'privilege_escalation': 75.0,
            'lateral_movement': 20.0,
            'timeout_penalty': -1.0,
            'failed_action': -2.0,
            'redundant_action': -0.5
        }
        
        # Use custom reward configuration if provided
        if reward_config:
            self.reward_config.update(reward_config)
        
        # Initialize scanner
        self.nm = nmap.PortScanner() if self.real_execution else None
        
        # Environment state
        self.discovered_hosts = []
        self.open_ports = {}  # {host: [ports]}
        self.services = {}    # {host: {port: service}}
        self.os_info = {}     # {host: os_info}
        self.vulnerabilities = {}  # {host: {port: [vulns]}}
        self.exploited = {}   # {host: {port: exploit_info}}
        self.privileges = {}  # {host: privilege_level}
        self.step_count = 0
        self.action_history = []
        
        # Action space: Discrete actions for different penetration testing operations
        # We define 8 action types (see ActionType enum)
        # For each action type, we need additional parameters
        self.action_space = spaces.Dict({
            'action_type': spaces.Discrete(len(ActionType)),
            'target_host': spaces.Discrete(256),  # Assuming /24 network
            'port': spaces.Discrete(65536),
            'extra_params': spaces.Text(max_length=200)  # For additional parameters
        })
        
        # Observation space: Network state representation
        self.observation_space = spaces.Dict({
            'discovered_hosts': spaces.Box(low=0, high=1, shape=(256,), dtype=np.int8),
            'open_ports': spaces.Box(low=0, high=1, shape=(256, 1024), dtype=np.int8),  # Tracking top 1024 ports
            'service_info': spaces.Box(low=0, high=1, shape=(256, 1024, 10), dtype=np.int8),  # 10 service types
            'os_detected': spaces.Box(low=0, high=1, shape=(256,), dtype=np.int8),
            'vulnerabilities': spaces.Box(low=0, high=1, shape=(256, 1024, 5), dtype=np.int8),  # 5 vuln categories
            'exploited': spaces.Box(low=0, high=1, shape=(256,), dtype=np.int8),
            'privilege_level': spaces.Box(low=0, high=2, shape=(256,), dtype=np.int8),  # 0=none, 1=user, 2=admin
            'step_count': spaces.Box(low=0, high=max_steps, shape=(1,), dtype=np.int32),
        })
        
        self.reset()
    
    def reset(self, *, seed=None, options=None):
        """Reset the environment to its initial state"""
        super().reset(seed=seed)
        
        self.discovered_hosts = []
        self.open_ports = {}
        self.services = {}
        self.os_info = {}
        self.vulnerabilities = {}
        self.exploited = {}
        self.privileges = {}
        self.step_count = 0
        self.action_history = []
        
        # Initial observation
        observation = self._get_observation()
        info = {}
        
        return observation, info
    
    def step(self, action: Dict[str, Any]) -> Tuple[Dict, float, bool, bool, Dict]:
        """
        Take a step in the environment by executing the given action
        
        Args:
            action: Dictionary containing action_type, target_host, port, and extra_params
            
        Returns:
            observation: Current observation of the environment
            reward: Reward for the action
            terminated: Whether the episode is terminated
            truncated: Whether the episode is truncated (e.g., by max steps)
            info: Additional information
        """
        action_type = ActionType(action['action_type'])
        target_host_idx = action['target_host']
        port = action['port']
        extra_params = action['extra_params']
        
        # Convert target_host_idx to an actual IP address in the target network
        # For simplicity, assume a /24 network and host index is last octet
        network_prefix = '.'.join(self.target_network.split('/')[0].split('.')[:-1])
        target_host = f"{network_prefix}.{target_host_idx}"
        
        reward = 0
        info = {
            'action_type': action_type.name,
            'target_host': target_host,
            'port': port,
            'success': False,
            'message': ""
        }
        
        # Check for redundant action
        if self._is_redundant_action(action_type, target_host, port, extra_params):
            reward += self.reward_config['redundant_action']
            info['message'] = "Redundant action"
        else:
            # Execute the action
            success, result = self._execute_action(action_type, target_host, port, extra_params)
            info['success'] = success
            info['message'] = result
            
            if success:
                # Update state and calculate reward based on the specific action
                reward += self._update_state_and_get_reward(action_type, target_host, port, result)
            else:
                reward += self.reward_config['failed_action']
        
        # Add the action to history
        self.action_history.append({
            'step': self.step_count,
            'action_type': action_type.name,
            'target_host': target_host,
            'port': port,
            'extra_params': extra_params,
            'success': info['success'],
            'result': info['message']
        })
        
        # Increment step count
        self.step_count += 1
        
        # Check if episode is done
        terminated = self._check_terminal_condition()
        truncated = self.step_count >= self.max_steps
        
        # Apply timeout penalty if truncated
        if truncated:
            reward += self.reward_config['timeout_penalty']
        
        # Get the current observation
        observation = self._get_observation()
        
        # Render if needed
        if self.render_mode is not None:
            self.render()
            
        return observation, reward, terminated, truncated, info
    
    def _execute_action(self, action_type: ActionType, target_host: str, port: int, 
                       extra_params: str) -> Tuple[bool, str]:
        """
        Execute the specified action in the environment
        
        Args:
            action_type: Type of action to execute
            target_host: Target host IP
            port: Target port
            extra_params: Additional parameters for the action
            
        Returns:
            success: Whether the action was successful
            result: Result or error message
        """
        if not self.real_execution:
            # Simulation mode - generate simulated responses
            return self._simulate_action(action_type, target_host, port, extra_params)
            
        try:
            # Real execution mode - execute actual commands
            if action_type == ActionType.SCAN_NETWORK:
                # Network scanning
                self.nm.scan(hosts=self.target_network, arguments="-sn")
                hosts = [h for h in self.nm.all_hosts() if self.nm[h].state() == "up"]
                return True, json.dumps({"hosts": hosts})
                
            elif action_type == ActionType.SCAN_PORT:
                # Port scanning
                self.nm.scan(hosts=target_host, arguments=f"-p {port}" if port < 65535 else "-p-")
                if target_host in self.nm.all_hosts():
                    ports = [int(p) for p in self.nm[target_host]['tcp'].keys()]
                    return True, json.dumps({"open_ports": ports})
                else:
                    return False, "Host not reachable"
                
            elif action_type == ActionType.SERVICE_DETECTION:
                # Service detection
                self.nm.scan(target_host, arguments=f"-p {port} -sV")
                if target_host in self.nm.all_hosts() and 'tcp' in self.nm[target_host]:
                    if port in self.nm[target_host]['tcp']:
                        service = self.nm[target_host]['tcp'][port]
                        return True, json.dumps(service)
                    return False, "Port not open"
                return False, "Host not reachable"
                
            elif action_type == ActionType.OS_DETECTION:
                # OS detection
                self.nm.scan(target_host, arguments="-O")
                if target_host in self.nm.all_hosts():
                    if 'osmatch' in self.nm[target_host]:
                        return True, json.dumps(self.nm[target_host]['osmatch'])
                    return False, "OS detection failed"
                return False, "Host not reachable"
                
            elif action_type == ActionType.VULN_SCAN:
                # Vulnerability scanning - this would typically use more specialized tools
                # This is a simplified version using nmap NSE scripts
                self.nm.scan(target_host, arguments=f"-p {port} --script vuln")
                if target_host in self.nm.all_hosts() and 'tcp' in self.nm[target_host]:
                    if port in self.nm[target_host]['tcp'] and 'script' in self.nm[target_host]['tcp'][port]:
                        return True, json.dumps(self.nm[target_host]['tcp'][port]['script'])
                    return False, "No vulnerabilities found or port not open"
                return False, "Host not reachable"
                
            elif action_type == ActionType.EXPLOIT_ATTEMPT:
                # Exploit attempt - would integrate with Metasploit or similar
                # For now, just simulating
                return self._simulate_action(action_type, target_host, port, extra_params)
                
            elif action_type == ActionType.PRIVILEGE_ESCALATION:
                # Privilege escalation - would need integration with actual exploits
                return self._simulate_action(action_type, target_host, port, extra_params)
                
            elif action_type == ActionType.LATERAL_MOVEMENT:
                # Lateral movement - simulated
                return self._simulate_action(action_type, target_host, port, extra_params)
                
            else:
                return False, f"Unknown action type: {action_type}"
                
        except Exception as e:
            self.logger.error(f"Error executing action {action_type} on {target_host}:{port}: {str(e)}")
            return False, f"Error: {str(e)}"
    
    def _simulate_action(self, action_type: ActionType, target_host: str, port: int, 
                        extra_params: str) -> Tuple[bool, str]:
        """
        Simulate action execution for testing without real network interaction
        
        This function provides simulated responses that mimic real network behavior
        but doesn't actually execute any commands on real systems.
        """
        # In a real implementation, this would be more sophisticated and based on
        # a simulated network topology with defined vulnerabilities
        
        if action_type == ActionType.SCAN_NETWORK:
            # Simulate discovering some hosts
            hosts = [f"192.168.1.{i}" for i in range(1, 6)]  # Simulate 5 hosts
            return True, json.dumps({"hosts": hosts})
            
        elif action_type == ActionType.SCAN_PORT:
            # Simulate finding some open ports
            common_ports = [21, 22, 80, 443, 3306, 8080]
            open_ports = [p for p in common_ports if np.random.random() > 0.6]
            if port in common_ports and np.random.random() > 0.7:
                open_ports.append(port)
            return True, json.dumps({"open_ports": open_ports})
            
        elif action_type == ActionType.SERVICE_DETECTION:
            # Simulate service detection
            services = {
                22: {"name": "ssh", "product": "OpenSSH", "version": "8.2p1"},
                80: {"name": "http", "product": "Apache httpd", "version": "2.4.41"},
                443: {"name": "https", "product": "Apache httpd", "version": "2.4.41"},
                3306: {"name": "mysql", "product": "MySQL", "version": "5.7.33"}
            }
            if port in services and np.random.random() > 0.2:
                return True, json.dumps(services[port])
            elif np.random.random() > 0.7:
                return True, json.dumps({"name": "unknown", "product": "", "version": ""})
            else:
                return False, "Service detection failed"
                
        elif action_type == ActionType.OS_DETECTION:
            # Simulate OS detection
            os_options = [
                {"name": "Linux", "accuracy": 95},
                {"name": "Windows", "accuracy": 92},
                {"name": "FreeBSD", "accuracy": 88}
            ]
            if np.random.random() > 0.3:
                return True, json.dumps(np.random.choice(os_options))
            else:
                return False, "OS detection failed"
                
        elif action_type == ActionType.VULN_SCAN:
            # Simulate vulnerability scan
            vuln_options = [
                {"id": "CVE-2020-1234", "severity": "high", "description": "SQL injection vulnerability"},
                {"id": "CVE-2021-5678", "severity": "medium", "description": "Cross-site scripting vulnerability"},
                {"id": "CVE-2019-8765", "severity": "critical", "description": "Remote code execution vulnerability"}
            ]
            if np.random.random() > 0.6:
                vulns = [v for v in vuln_options if np.random.random() > 0.7]
                return True, json.dumps(vulns) if vulns else "No vulnerabilities found"
            else:
                return False, "Vulnerability scan failed"
                
        elif action_type == ActionType.EXPLOIT_ATTEMPT:
            # Simulate exploit attempt
            success_rate = 0.3  # 30% chance of successful exploit
            if np.random.random() < success_rate:
                exploit_result = {
                    "success": True,
                    "exploit": f"exploit/generic/{extra_params}",
                    "session_id": np.random.randint(1000, 9999)
                }
                return True, json.dumps(exploit_result)
            else:
                return False, "Exploit failed"
                
        elif action_type == ActionType.PRIVILEGE_ESCALATION:
            # Simulate privilege escalation
            success_rate = 0.2  # 20% chance of successful privilege escalation
            if np.random.random() < success_rate:
                escalation_result = {
                    "success": True,
                    "previous_level": "user",
                    "new_level": "administrator",
                    "method": f"{extra_params}"
                }
                return True, json.dumps(escalation_result)
            else:
                return False, "Privilege escalation failed"
                
        elif action_type == ActionType.LATERAL_MOVEMENT:
            # Simulate lateral movement
            success_rate = 0.25  # 25% chance of successful lateral movement
            if np.random.random() < success_rate:
                target_host = f"192.168.1.{np.random.randint(1, 10)}"
                lateral_result = {
                    "success": True,
                    "source": target_host,
                    "destination": f"192.168.1.{np.random.randint(10, 20)}",
                    "method": f"{extra_params}"
                }
                return True, json.dumps(lateral_result)
            else:
                return False, "Lateral movement failed"
        
        return False, "Unknown action or simulation failure"
    
    def _update_state_and_get_reward(self, action_type: ActionType, target_host: str, 
                                   port: int, result: str) -> float:
        """
        Update environment state based on action result and return reward
        
        Args:
            action_type: Type of action executed
            target_host: Target host IP
            port: Target port
            result: Result string from action execution
            
        Returns:
            reward: Reward value for this state update
        """
        reward = 0.0
        
        try:
            if action_type == ActionType.SCAN_NETWORK:
                # Update discovered hosts
                result_dict = json.loads(result)
                hosts = result_dict.get("hosts", [])
                new_hosts = [h for h in hosts if h not in self.discovered_hosts]
                self.discovered_hosts.extend(new_hosts)
                reward += len(new_hosts) * self.reward_config['discover_host']
                
            elif action_type == ActionType.SCAN_PORT:
                # Update open ports
                if target_host not in self.open_ports:
                    self.open_ports[target_host] = []
                    
                result_dict = json.loads(result)
                ports = result_dict.get("open_ports", [])
                new_ports = [p for p in ports if p not in self.open_ports.get(target_host, [])]
                self.open_ports[target_host].extend(new_ports)
                reward += len(new_ports) * self.reward_config['open_port']
                
            elif action_type == ActionType.SERVICE_DETECTION:
                # Update service information
                if target_host not in self.services:
                    self.services[target_host] = {}
                    
                result_dict = json.loads(result)
                if port not in self.services.get(target_host, {}):
                    self.services[target_host][port] = result_dict
                    reward += self.reward_config['service_identified']
                
            elif action_type == ActionType.OS_DETECTION:
                # Update OS information
                result_dict = json.loads(result)
                if target_host not in self.os_info:
                    self.os_info[target_host] = result_dict
                    reward += self.reward_config['os_identified']
                
            elif action_type == ActionType.VULN_SCAN:
                # Update vulnerability information
                if target_host not in self.vulnerabilities:
                    self.vulnerabilities[target_host] = {}
                    
                result_dict = json.loads(result)
                if isinstance(result_dict, list) and result_dict:
                    if port not in self.vulnerabilities.get(target_host, {}):
                        self.vulnerabilities[target_host][port] = []
                        
                    new_vulns = [v for v in result_dict if v not in self.vulnerabilities.get(target_host, {}).get(port, [])]
                    self.vulnerabilities[target_host][port].extend(new_vulns)
                    reward += len(new_vulns) * self.reward_config['vulnerability_found']
                
            elif action_type == ActionType.EXPLOIT_ATTEMPT:
                # Update exploit status
                result_dict = json.loads(result)
                if result_dict.get("success", False):
                    if target_host not in self.exploited:
                        self.exploited[target_host] = {}
                    
                    self.exploited[target_host][port] = result_dict
                    reward += self.reward_config['successful_exploit']
                    
                    # By default, successful exploit gives user privileges
                    if target_host not in self.privileges:
                        self.privileges[target_host] = 1  # 1 = user privileges
                
            elif action_type == ActionType.PRIVILEGE_ESCALATION:
                # Update privilege level
                result_dict = json.loads(result)
                if result_dict.get("success", False):
                    # Update privilege level to highest (2 = administrator)
                    self.privileges[target_host] = 2
                    reward += self.reward_config['privilege_escalation']
                
            elif action_type == ActionType.LATERAL_MOVEMENT:
                # Update for lateral movement
                result_dict = json.loads(result)
                if result_dict.get("success", False):
                    dest_host = result_dict.get("destination", "")
                    if dest_host and dest_host not in self.discovered_hosts:
                        self.discovered_hosts.append(dest_host)
                        reward += self.reward_config['lateral_movement']
        
        except (json.JSONDecodeError, TypeError, KeyError) as e:
            self.logger.error(f"Error updating state: {str(e)}, result: {result}")
        
        return reward
    
    def _is_redundant_action(self, action_type: ActionType, target_host: str, port: int, 
                            extra_params: str) -> bool:
        """Check if the action would be redundant given the current state"""
        if action_type == ActionType.SCAN_NETWORK:
            # Redundant if we've already scanned the network
            return len(self.action_history) > 0 and any(
                a['action_type'] == ActionType.SCAN_NETWORK.name for a in self.action_history
            )
            
        elif action_type == ActionType.SCAN_PORT:
            # Redundant if we've already scanned this host's ports
            return any(
                a['action_type'] == ActionType.SCAN_PORT.name and
                a['target_host'] == target_host and
                a['success'] == True  # Successfully scanned this host before
                for a in self.action_history
            )
            
        elif action_type == ActionType.SERVICE_DETECTION:
            # Redundant if we've already identified this service
            return target_host in self.services and port in self.services.get(target_host, {})
            
        elif action_type == ActionType.OS_DETECTION:
            # Redundant if we've already identified this OS
            return target_host in self.os_info
            
        elif action_type == ActionType.VULN_SCAN:
            # Redundant if we've already scanned for vulnerabilities on this port
            return (target_host in self.vulnerabilities and 
                    port in self.vulnerabilities.get(target_host, {}))
            
        elif action_type == ActionType.EXPLOIT_ATTEMPT:
            # Redundant if we've already successfully exploited this host:port
            return (target_host in self.exploited and 
                    port in self.exploited.get(target_host, {}))
            
        elif action_type == ActionType.PRIVILEGE_ESCALATION:
            # Redundant if we already have admin privileges
            return target_host in self.privileges and self.privileges[target_host] == 2
            
        elif action_type == ActionType.LATERAL_MOVEMENT:
            # Hard to determine redundancy for lateral movement without more context
            return False
            
        return False
    
    def _check_terminal_condition(self) -> bool:
        """Check if the episode should terminate based on the current state"""
        # Example terminal condition: All hosts exploited with admin privileges
        if self.discovered_hosts:
            all_exploited = all(host in self.exploited for host in self.discovered_hosts)
            all_admin = all(
                host in self.privileges and self.privileges[host] == 2 
                for host in self.discovered_hosts
            )
            return all_exploited and all_admin
        
        return False
    
    def _get_observation(self) -> Dict[str, np.ndarray]:
        """Convert environment state to agent observation space"""
        # Initialize observation arrays with zeros
        discovered_hosts = np.zeros(256, dtype=np.int8)
        open_ports = np.zeros((256, 1024), dtype=np.int8)
        service_info = np.zeros((256, 1024, 10), dtype=np.int8)
        os_detected = np.zeros(256, dtype=np.int8)
        vulnerabilities = np.zeros((256, 1024, 5), dtype=np.int8)
        exploited = np.zeros(256, dtype=np.int8)
        privilege_level = np.zeros(256, dtype=np.int8)
        
        # Fill in the arrays based on current state
        for host in self.discovered_hosts:
            try:
                # Extract the last octet as the host index
                host_idx = int(host.split('.')[-1])
                if 0 <= host_idx < 256:
                    discovered_hosts[host_idx] = 1
                    
                    # Open ports
                    if host in self.open_ports:
                        for port in self.open_ports[host]:
                            if port < 1024:
                                open_ports[host_idx, port] = 1
                    
                    # Services - simplified encoding
                    if host in self.services:
                        for port, service in self.services[host].items():
                            if port < 1024:
                                # Encode service type (simplified)
                                service_name = service.get("name", "").lower()
                                service_encoding = {
                                    'http': 0, 'https': 1, 'ftp': 2, 'ssh': 3,
                                    'telnet': 4, 'smtp': 5, 'dns': 6, 'mysql': 7,
                                    'mssql': 8
                                }
                                service_idx = service_encoding.get(service_name, 9)  # 9 for other
                                service_info[host_idx, port, service_idx] = 1
                    
                    # OS detection
                    if host in self.os_info:
                        os_detected[host_idx] = 1
                    
                    # Vulnerabilities - simplified encoding
                    if host in self.vulnerabilities:
                        for port, vulns in self.vulnerabilities[host].items():
                            if port < 1024 and vulns:
                                for i, vuln in enumerate(vulns[:5]):  # Only consider up to 5 vulns
                                    vuln_severity = vuln.get("severity", "").lower()
                                    severity_encoding = {
                                        'low': 0, 'medium': 1, 'high': 2, 'critical': 3
                                    }
                                    severity_idx = severity_encoding.get(vuln_severity, 4)  # 4 for unknown
                                    vulnerabilities[host_idx, port, severity_idx] = 1
                    
                    # Exploited status
                    if host in self.exploited:
                        exploited[host_idx] = 1
                    
                    # Privilege level
                    if host in self.privileges:
                        privilege_level[host_idx] = self.privileges[host]
            except (ValueError, IndexError) as e:
                self.logger.error(f"Error converting host {host} to observation: {str(e)}")
        
        # Normalized step count
        step_count = np.array([self.step_count / self.max_steps], dtype=np.float32)
        
        return {
            'discovered_hosts': discovered_hosts,
            'open_ports': open_ports,
            'service_info': service_info,
            'os_detected': os_detected,
            'vulnerabilities': vulnerabilities,
            'exploited': exploited,
            'privilege_level': privilege_level,
            'step_count': step_count
        }
    
    def render(self):
        """Render the environment"""
        if self.render_mode == 'human' or self.render_mode == 'ansi':
            output = [
                f"Step: {self.step_count}/{self.max_steps}",
                f"Discovered hosts: {len(self.discovered_hosts)}",
                f"Hosts with open ports: {len(self.open_ports)}",
                f"Services identified: {sum(len(services) for services in self.services.values())}",
                f"OS identified: {len(self.os_info)}",
                f"Vulnerabilities found: {sum(len(vulns) for host_vulns in self.vulnerabilities.values() for vulns in host_vulns.values())}",
                f"Exploited hosts: {len(self.exploited)}",
                f"Hosts with admin privileges: {sum(1 for level in self.privileges.values() if level == 2)}"
            ]
            
            print('\n'.join(output))
            
            # Print the last action if available
            if self.action_history:
                last_action = self.action_history[-1]
                print(f"\nLast action: {last_action['action_type']} on {last_action['target_host']}:{last_action['port']}")
                print(f"Success: {last_action['success']}")
                print(f"Result: {last_action['result'][:100]}...")
            
            if self.render_mode == 'human':
                # Add a small delay for human viewing
                time.sleep(0.5)
    
    def close(self):
        """Clean up resources"""
        pass
    
    def get_action_history(self) -> List[Dict]:
        """Return the action history"""
        return self.action_history
    
    def get_report(self) -> Dict[str, Any]:
        """Generate a penetration testing report"""
        report = {
            'summary': {
                'total_hosts_discovered': len(self.discovered_hosts),
                'hosts_with_open_ports': len(self.open_ports),
                'hosts_with_vulnerabilities': len(self.vulnerabilities),
                'exploited_hosts': len(self.exploited),
                'hosts_with_admin_privileges': sum(1 for level in self.privileges.values() if level == 2)
            },
            'hosts': {}
        }
        
        for host in self.discovered_hosts:
            host_info = {
                'open_ports': self.open_ports.get(host, []),
                'services': self.services.get(host, {}),
                'os_info': self.os_info.get(host, {}),
                'vulnerabilities': self.vulnerabilities.get(host, {}),
                'exploited': host in self.exploited,
                'privilege_level': self.privileges.get(host, 0)
            }
            report['hosts'][host] = host_info
        
        return report 